<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <!-- CSP：YouTubeのみ許可 -->
  <meta http-equiv="Content-Security-Policy"
        content="
          default-src 'self';
          script-src 'self' https://www.youtube.com https://www.youtube-nocookie.com https://s.ytimg.com 'unsafe-inline';
          style-src  'self' 'unsafe-inline';
          img-src    'self' data: blob: https://i.ytimg.com;
          frame-src  https://www.youtube.com https://www.youtube-nocookie.com;
          connect-src 'self' https://www.youtube.com https://*.googlevideo.com;
          media-src  https://*.googlevideo.com;
          font-src   'self' data:;
          object-src 'none';
          base-uri   'self';
          form-action 'self';
        ">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>福島第一 ３Ｄ動画 被災翌年/現在（同期比較・停止比較・FS対応）</title>
  <meta name="description" content="福島第一原発3DGS（2012/2025）を同期再生。停止フレーム比較、フェード/スライダー、全画面（未対応環境は疑似FS）対応。" />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='46' fill='%235b9cff'/%3E%3Ctext x='50' y='58' text-anchor='middle' font-size='56' fill='white' font-family='Arial, sans-serif'%3EF%3C/text%3E%3C/svg%3E" />
  <style>
    :root { --bg:#0f1115; --panel:#151822; --muted:#9aa3b2; --fg:#e7ebf3; --accent:#5b9cff; --radius:16px; }
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 800px at 80% -10%,#1b2030 0%,var(--bg) 40%,var(--bg) 100%);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans JP,Helvetica,Arial}
    .wrap{max-width:1500px;margin:24px auto;padding:0 16px 48px}
    .header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:12px}
    .title{font-size:clamp(18px,2.4vw,28px);font-weight:700}
    .note{color:var(--muted);font-size:12px}

    /* 疑似フルスクリーン用（iOS等）★ */
    .pseudo-fs body, body.pseudo-fs {overflow:hidden;}
    body.pseudo-fs .wrap{max-width:none;padding:0}
    body.pseudo-fs .video-shell{position:fixed;inset:0;z-index:9999;border-radius:0;width:100vw;aspect-ratio:auto}
    body.pseudo-fs .panel{position:fixed;left:0;right:0;bottom:0;margin:0;border-radius:0}

    .video-shell{
      position:relative;
      width: clamp(320px, 96vw, 1400px);
      margin:0 auto;
      aspect-ratio:16/9;
      background:#0b0d13;border:1px solid #20273a;border-radius:var(--radius);
      overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.04);
      isolation:isolate;user-select:none
    }
    .layer{position:absolute;inset:0}
    .layer iframe{position:absolute;inset:0;width:100%;height:100%;border:0;pointer-events:none}
    #video-shell{pointer-events:none} .controls,.slider-handle,.overlay-button,.fs-btn{pointer-events:auto}

    /* スライダー */
    .slider-handle{position:absolute;top:0;bottom:0;width:2px;background:#ffffff66;left:50%;cursor:ew-resize;z-index:5}
    .slider-dot{position:absolute;top:50%;transform:translate(-50%,-50%);left:50%;width:18px;height:18px;border-radius:50%;background:#fff;box-shadow:0 0 0 4px rgba(0,0,0,.35)}

    /* イントロ */
    #intro-overlay{display:grid;place-items:center;background:linear-gradient(180deg,#0b0f1a88,#0b0f1a88);pointer-events:auto;z-index:6}
    .intro-mask{position:absolute;inset:0;background:radial-gradient(60% 60% at 50% 40%,#ffffff08,transparent 70%);mix-blend-mode:screen}
    .intro-center{text-align:center;padding:24px 16px;backdrop-filter:blur(2px);display:grid;gap:12px;justify-items:center}
    .intro-title{font-weight:800;letter-spacing:.5px;font-size:clamp(16px,3.2vw,28px);margin-bottom:8px}
    .intro-sub{color:var(--muted);font-size:13px}
    .intro-progress{width:min(520px,80vw)}
    .intro-progress-bar{position:relative;height:10px;border-radius:999px;background:#1f2a44;overflow:hidden}
    .intro-progress-bar::before{content:"";position:absolute;inset:0;width:var(--p,0%);background:linear-gradient(90deg,#ff6a6a,#e53935)}
    #intro-progress-label{position:absolute;right:8px;top:50%;transform:translateY(-50%);font-size:11px;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.4)}
    .btn-primary{background:linear-gradient(180deg,#2a6cff,#164cff);color:#fff;border:1px solid #335fff;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer}
    .btn-primary[disabled]{opacity:.6;cursor:not-allowed}

    /* ポーズ時の極薄シールド（中央アイコンを隠す／フレームは見える）★ */
    #pause-shield{
      position:absolute;inset:0;background:rgba(0,0,0,0.001); /* ほぼ透明でも前面に来るので下のUIを隠せる */
      display:none;z-index:7;
    }
    #pause-shield.visible{display:block}
    .overlay-button{display:none} /* 自動再生不可の時だけ別途使うので通常は非表示にする */

    /* フルスクリーンボタン */
    .fs-btn{
      position:absolute;top:10px;right:10px;z-index:8;
      background:linear-gradient(180deg,#1a2233,#111725);color:var(--fg);
      border:1px solid #26324a;padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer
    }
    .fs-exit{
      position:absolute;top:10px;left:10px;z-index:8;display:none;
      background:linear-gradient(180deg,#1a2233,#111725);color:var(--fg);
      border:1px solid #26324a;padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer
    }
    .fs-exit.visible{display:block}

    .panel{background:linear-gradient(180deg,#161b27,#121620);border:1px solid #20273a;border-radius:var(--radius);padding:14px;display:grid;gap:12px;box-shadow:0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.04)}
    .row{display:grid;gap:8px;align-items:center}
    .row.inline{grid-template-columns:auto 1fr auto;gap:10px}
    .buttons{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{background:linear-gradient(180deg,#1a2233,#111725);color:var(--fg);border:1px solid #26324a;padding:10px 12px;border-radius:12px;font-weight:600;cursor:pointer;transition:transform .02s ease,filter .15s ease,background .2s ease}
    button:hover{filter:brightness(1.08)} button:active{transform:scale(.98)}
    button[aria-pressed="true"]{outline:2px solid var(--accent)}
    .seg-btn{border-radius:999px;padding:8px 14px}
    .time{font-variant-numeric:tabular-nums}

    /* シーク */
    #seek{height:28px;-webkit-appearance:none;background:transparent;border-radius:999px;padding:10px 0;
      background-image:
        linear-gradient(rgba(255,255,255,.25), rgba(255,255,255,.25)),
        linear-gradient(rgba(255,255,255,.60), rgba(255,255,255,.60)),
        linear-gradient(#e53935,#e53935);
      background-repeat:no-repeat;
      background-size:100% 6px, var(--buf,0%) 6px, var(--p,0%) 6px;
      background-position:left center,left center,left center;
    }
    #seek::-webkit-slider-runnable-track{height:6px;background:transparent;border-radius:999px}
    #seek::-moz-range-track{height:6px;background:transparent;border-radius:999px}
    #seek::-ms-track{height:6px;background:transparent;border-radius:999px;border-color:transparent;color:transparent}
    #seek::-webkit-slider-thumb{-webkit-appearance:none;width:16px;height:16px;border-radius:50%;background:#e53935;border:0;box-shadow:0 0 0 6px rgba(229,57,53,.25);transition:transform .12s ease,box-shadow .12s ease}
    #seek::-moz-range-thumb{width:16px;height:16px;border-radius:50%;background:#e53935;border:0;box-shadow:0 0 0 6px rgba(229,57,53,.25);transition:transform .12s ease,box-shadow .12s ease}
    #seek:hover::-webkit-slider-thumb,#seek:active::-webkit-slider-thumb{transform:scale(1.15);box-shadow:0 0 0 8px rgba(229,57,53,.2)}
    #seek:hover::-moz-range-thumb,#seek:active::-moz-range-thumb{transform:scale(1.15);box-shadow:0 0 0 8px rgba(229,57,53,.2)}

    .transport-buttons{display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap}
    .transport-buttons .primary{font-weight:800}

    @media (max-width: 480px) {
      .transport-buttons{ gap: 8px; }
      .buttons .btn{ padding: 8px 10px; font-size: 14px; }
      .title{ font-size: clamp(16px, 4.8vw, 22px); }
      #seek{ height: 36px; }
      .video-shell{ width: 100vw; border-radius: 0; }
    }

    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div class="title">福島第一 ３Ｄ動画 被災翌年/現在（同期比較・停止比較・FS対応）</div>
    </div>

    <div class="video-shell" id="video-shell" aria-label="比較ビュー">
      <!-- 全画面：入る / 戻る -->
      <button id="fs-enter" class="fs-btn" aria-label="全画面表示">⤢ 全画面</button>
      <button id="fs-exit" class="fs-exit" aria-label="全画面を終了">⤡ 戻る</button>

      <div class="layer" id="layer-before"><div id="yt-before"></div></div>
      <div class="layer" id="layer-after"><div id="yt-after"></div></div>

      <!-- スライダー -->
      <div class="slider-handle" id="slider-handle" hidden><div class="slider-dot"></div></div>

      <!-- ポーズ時のみ出す極薄シールド（イントロ中は出さない）★ -->
      <div id="pause-shield" aria-hidden="true"></div>

      <!-- イントロ -->
      <div class="layer" id="intro-overlay" role="dialog" aria-modal="true">
        <div class="intro-mask"></div>
        <div class="intro-center">
          <div class="intro-title">福島第一 被災翌年/現在 比較</div>
          <div class="intro-sub" id="intro-sub">同期準備中… バッファリング完了後に自動再生</div>
          <div class="intro-progress"><div class="intro-progress-bar" id="intro-progress-bar"><span id="intro-progress-label">0%</span></div></div>
          <button id="intro-start-btn" class="btn-primary" disabled>再生開始</button>
          <label class="intro-toggle"><input type="checkbox" id="intro-autostart" checked> 準備完了で自動再生</label>
        </div>
      </div>
    </div>

    <div class="panel controls">
      <div class="row">
        <div class="buttons" role="group" aria-label="表示モード">
          <button id="btn-mode-slider"      class="btn seg-btn" aria-pressed="true">スライダー比較</button>
          <button id="btn-mode-fade"        class="btn seg-btn" aria-pressed="false">フェード比較</button>
          <button id="btn-mode-only-before" class="btn seg-btn" aria-pressed="false">被災翌年のみ</button>
          <button id="btn-mode-only-after"  class="btn seg-btn" aria-pressed="false">現在のみ</button>
        </div>
      </div>

      <div class="row inline" id="fade-controls" aria-live="polite" style="display:none">
        <label for="fade-range">フェード量</label>
        <input type="range" id="fade-range" min="0" max="100" value="50" step="1" />
        <span id="fade-pct" class="time">50%</span>
      </div>

      <div class="row" id="transport">
        <div class="transport-buttons">
          <button id="rewind-5">⟲ -5秒</button>
          <button id="play-pause" class="primary" aria-pressed="false">▶ 再生</button>
          <button id="forward-5">+5秒 ⟳</button>
          <span class="time" id="time-readout">00:00 / 00:00</span>
        </div>
        <input type="range" id="seek" min="0" max="0" value="0" step="0.01" aria-label="シークバー" />
      </div>
    </div>

    <p class="note">
      動画提供:
      <a href="https://youtu.be/WOw9BryHb_4" target="_blank" rel="noreferrer noopener">被災翌年（2012-03-01撮影）</a> /
      <a href="https://youtu.be/KKNWwr_9590" target="_blank" rel="noreferrer noopener">現在（2025-01-27撮影）</a>
      （YouTube）
    </p>
  </div>

  <script src="https://www.youtube.com/iframe_api"></script>
  <script>
    // ==== 動画ID ====
    const VIDEO_BEFORE = { id: 'WOw9BryHb_4', label: '被災翌年' };
    const VIDEO_AFTER  = { id: 'KKNWwr_9590', label: '現在' };

    // ==== 同期・適応制御 ====
    const SYNC_FINE = 0.08, SYNC_HARD = 0.50, FINE_COOLDOWN_MS = 500;
    const MIN_BUFFER_FRAC = 0.10, MIN_BUFFER_SEC = 5;
    const RESYNC_BUFFER_FRAC = 0.18, RESYNC_BUFFER_SEC = 8;
    const AUTOPLAY_WATCH_MS_1 = 500, AUTOPLAY_WATCH_MS_2 = 1500;

    let playerBefore=null, playerAfter=null, duration=0;
    let isReadyA=false, isReadyB=false, isPlaying=false;
    let introRunning=true, autoplayBlocked=false, started=false;
    let rafId=null, intervalId=null, lastFineAdjustAt=0;
    let bufferWatchTimer=null, followerHolding=false;

    const el=id=>document.getElementById(id);
    const layerBefore=el('layer-before'), layerAfter=el('layer-after'), shell=el('video-shell');
    const sliderHandle=el('slider-handle'), playPause=el('play-pause');
    const seek=el('seek'), timeReadout=el('time-readout');
    const fadeRange=el('fade-range'), fadePct=el('fade-pct');
    const introOverlay=el('intro-overlay'), introBtn=el('intro-start-btn'), introSub=el('intro-sub');
    const introProgBar=el('intro-progress-bar'), introProgLabel=el('intro-progress-label'), introAuto=el('intro-autostart');
    const btnModeSlider=el('btn-mode-slider'), btnModeFade=el('btn-mode-fade'), btnOnlyBefore=el('btn-mode-only-before'), btnOnlyAfter=el('btn-mode-only-after');
    const pauseShield=el('pause-shield');
    const fsEnter=el('fs-enter'), fsExit=el('fs-exit');

    // 表示モード
    let currentMode='slider';
    function setActive(btn,on){btn.setAttribute('aria-pressed',on?'true':'false')}
    function applySplit(p){p=Math.max(0,Math.min(100,p));layerAfter.style.clipPath=`inset(0 0 0 ${p}%)`;sliderHandle.style.left=p+'%'}
    function setMode(mode){
      currentMode=mode;
      setActive(btnModeSlider,mode==='slider'); setActive(btnModeFade,mode==='fade');
      setActive(btnOnlyBefore,mode==='only-before'); setActive(btnOnlyAfter,mode==='only-after');
      const fadeRow=document.getElementById('fade-controls'); if(fadeRow) fadeRow.style.display=(mode==='fade')?'':'none';
      layerBefore.style.display=''; layerAfter.style.display='';
      if(mode==='fade'){
        layerAfter.style.clipPath=''; layerAfter.style.width='100%';
        layerAfter.style.opacity=(fadeRange.valueAsNumber/100).toFixed(2);
        sliderHandle.hidden=true; fadeRange.disabled=false;
      }else if(mode==='slider'){
        fadeRange.disabled=true; sliderHandle.hidden=false; layerAfter.style.opacity=1; applySplit(parseFloat(sliderHandle.style.left)||50);
      }else if(mode==='only-before'){
        sliderHandle.hidden=true; fadeRange.disabled=true; layerAfter.style.display='none';
      }else if(mode==='only-after'){
        sliderHandle.hidden=true; fadeRange.disabled=true; layerAfter.style.display=''; layerAfter.style.opacity=1; layerAfter.style.clipPath='inset(0 0 0 0)';
      }
    }
    btnModeSlider.addEventListener('click',()=>setMode('slider'));
    btnModeFade.addEventListener('click',()=>setMode('fade'));
    btnOnlyBefore.addEventListener('click',()=>setMode('only-before'));
    btnOnlyAfter.addEventListener('click',()=>setMode('only-after'));
    fadeRange.addEventListener('input',()=>{const v=fadeRange.valueAsNumber;fadePct.textContent=v+'%';if(currentMode==='fade')layerAfter.style.opacity=(v/100).toFixed(2)})

    // スライダードラッグ
    let dragging=false;
    const onDown=(e)=>{dragging=true; e.preventDefault?.()};
    const onUp=()=>{dragging=false};
    const onMove=e=>{
      if(!dragging||currentMode!=='slider')return;
      e.preventDefault?.();
      const pt = e.touches?e.touches[0]:e;
      const rect=shell.getBoundingClientRect(), x=pt.clientX-rect.left;
      applySplit(Math.max(0,Math.min(100,(x/rect.width)*100)));
    };
    sliderHandle.addEventListener('mousedown',onDown); window.addEventListener('mouseup',onUp); window.addEventListener('mousemove',onMove);
    sliderHandle.addEventListener('touchstart',onDown,{passive:false}); window.addEventListener('touchend',onUp); window.addEventListener('touchmove',onMove,{passive:false});

    // バッファ表示/時間UI
    let totalDuration=0;
    function formatTime(sec){const s=Math.max(0,Math.floor(sec||0));const m=Math.floor(s/60),r=s%60;return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`}
    function updateBufferUI(current){
      if(!Number.isFinite(totalDuration)||totalDuration<=0)return;
      const fA=playerBefore?.getVideoLoadedFraction?.()||0, fB=playerAfter?.getVideoLoadedFraction?.()||0;
      const frac=Math.max(0,Math.min(1,Math.min(fA,fB)));
      const played=Math.max(0,Math.min(1,(current||0)/totalDuration));
      seek.style.setProperty('--buf',(frac*100)+'%'); seek.style.setProperty('--p',(played*100)+'%');
      introProgBar.style.setProperty('--p',(frac*100)+'%'); introProgLabel.textContent=Math.round(frac*100)+'%';
    }
    function updateSeekUI(t){
      if(!Number.isFinite(totalDuration)||totalDuration<=0)return;
      const c=Math.min(totalDuration,Math.max(0,t)); seek.max=totalDuration.toFixed(2); seek.value=c.toFixed(2);
      timeReadout.textContent=`${formatTime(c)} / ${formatTime(totalDuration)} (−${formatTime(Math.max(0,totalDuration-c))})`;
      updateBufferUI(c);
    }

    // 再生/一時停止（ポーズ時は薄シールドで中央アイコンを隠す）★
    function showPauseShield(on){ if(introRunning) return; pauseShield.classList.toggle('visible', !!on); }
    function playBoth(){ try{playerBefore.playVideo()}catch{} try{playerAfter.playVideo()}catch{} isPlaying=true; playPause.textContent='⏸ 一時停止'; playPause.setAttribute('aria-pressed','true'); showPauseShield(false); }
    function pauseBoth(){ try{playerBefore.pauseVideo()}catch{} try{playerAfter.pauseVideo()}catch{} isPlaying=false; playPause.textContent='▶ 再生'; playPause.setAttribute('aria-pressed','false'); showPauseShield(true); }

    playPause.addEventListener('click',()=>{ if(!isReadyA||!isReadyB||introRunning)return; isPlaying?pauseBoth():playBoth(); });
    el('rewind-5').addEventListener('click',()=>nudge(-5)); el('forward-5').addEventListener('click',()=>nudge(+5));
    function nudge(d){if(!isReadyA||!isReadyB)return;const t=Math.max(0,Math.min(totalDuration,playerBefore.getCurrentTime()+d));seekToBoth(t,true)}
    seek.addEventListener('input',()=>updateSeekUI(parseFloat(seek.value))); seek.addEventListener('change',()=>seekToBoth(parseFloat(seek.value),true));
    window.addEventListener('keydown',(e)=>{
      if(introRunning) return;
      if(e.key===' '){ e.preventDefault(); isPlaying?pauseBoth():playBoth(); }
      if(e.key==='ArrowLeft'){ e.preventDefault(); nudge(e.shiftKey?-5:-1); }
      if(e.key==='ArrowRight'){ e.preventDefault(); nudge(e.shiftKey?+5:+1); }
      if(e.key.toLowerCase()==='f'){ e.preventDefault(); toggleFullscreen(); }
    });

    // フルスクリーン + 疑似FSフォールバック★
    function inFS(){ return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement); }
    function canFS(){ return !!(document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen || document.documentElement.msRequestFullscreen); }
    function reqFS(el){
      const fn = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen || el.mozRequestFullScreen;
      if (fn) { fn.call(el); return true; }
      return false;
    }
    function exitFS(){
      const fn = document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen || document.mozCancelFullScreen;
      if (fn) { fn.call(document); return true; }
      return false;
    }
    function enterPseudoFS(){ document.body.classList.add('pseudo-fs'); }
    function exitPseudoFS(){ document.body.classList.remove('pseudo-fs'); }
    function toggleFullscreen(){
      if(inFS()){ exitFS(); return; }
      // まずネイティブFSを試行、ダメなら疑似FS
      const ok = reqFS(shell);
      if(!ok){ enterPseudoFS(); }
    }
    fsEnter.addEventListener('click', toggleFullscreen);
    fsExit.addEventListener('click', ()=>{ if(!exitFS()) exitPseudoFS(); });
    function onFSChange(){
      const active = inFS() || document.body.classList.contains('pseudo-fs');
      fsExit.classList.toggle('visible', active);
    }
    document.addEventListener('fullscreenchange', onFSChange);
    document.addEventListener('webkitfullscreenchange', onFSChange);

    // 同期ヘルパ
    function bufferedEnough(p, frac=MIN_BUFFER_FRAC, sec=MIN_BUFFER_SEC){
      const dur=p.getDuration()||0, f=(p.getVideoLoadedFraction?p.getVideoLoadedFraction():0)||0;
      const have=Math.max(f*dur, p.getCurrentTime?p.getCurrentTime():0), need=Math.max(frac*dur, sec);
      return have>=need;
    }
    function seekToBoth(t, allow){ playerBefore.seekTo(t, allow); playerAfter.seekTo(t, allow); updateSeekUI(t); }

    // rAF同期（二段階補正 + 低速ホールド）
    function syncStep() {
      if (!isReadyA || !isReadyB) { scheduleNext(); return; }

      const stA = playerBefore.getPlayerState?.();
      const stB = playerAfter.getPlayerState?.();

      // 再生中以外（＝一時停止を含む）はUIのみ
      if (stA !== YT.PlayerState.PLAYING || stB !== YT.PlayerState.PLAYING) {
        updateSeekUI(playerBefore.getCurrentTime());
        scheduleNext();
        return;
      }

      const leaderOK = bufferedEnough(playerBefore);
      const followerOK = bufferedEnough(playerAfter);
      const followerOKForResync = bufferedEnough(playerAfter, RESYNC_BUFFER_FRAC, RESYNC_BUFFER_SEC);

      if (leaderOK && !followerOK) {
        if (!followerHolding){ try{ playerAfter.pauseVideo(); }catch{} followerHolding = true; }
        updateSeekUI(playerBefore.getCurrentTime()); scheduleNext(); return;
      }
      if (followerHolding && followerOKForResync) {
        const ta = playerBefore.getCurrentTime();
        playerAfter.seekTo(ta, /*allowSeekAhead=*/true);
        try{ playerAfter.playVideo(); }catch{}
        followerHolding = false;
        lastFineAdjustAt = performance.now();
      }

      const ta = playerBefore.getCurrentTime();
      const tb = playerAfter.getCurrentTime();
      const drift = tb - ta;

      if (!followerHolding && leaderOK && followerOK) {
        const now = performance.now();
        if (Math.abs(drift) > 0.50) { playerAfter.seekTo(ta, true); lastFineAdjustAt = now; }
        else if (Math.abs(drift) > 0.08 && (now - lastFineAdjustAt > 500)) { playerAfter.seekTo(ta, false); lastFineAdjustAt = now; }
      }

      updateSeekUI(ta);
      scheduleNext();
    }
    function scheduleNext(){
      if (document.visibilityState === 'visible' && isPlaying) {
        rafId = requestAnimationFrame(syncStep);
      } else {
        intervalId = setTimeout(syncStep, 160);
      }
    }
    function startTicking(){ if (!rafId && !intervalId) scheduleNext(); }
    function stopTicking(){ if (rafId){ cancelAnimationFrame(rafId); rafId = null; } if (intervalId){ clearTimeout(intervalId); intervalId = null; } }
    document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible'){ if (isPlaying){ stopTicking(); startTicking(); } } else { stopTicking(); } });

    // イントロ
    let introRAF=null;
    function startIntroAnimation(){
      let dir=1, fadeValue=40, splitValue=50;
      const fadeMin=30,fadeMax=70,fadeSpeed=0.01, splitMin=25,splitMax=75,splitSpeed=0.015;
      function frame(){
        if(!introRunning)return;
        if(currentMode==='fade'){
          fadeValue+=dir*fadeSpeed*16; if(fadeValue>=fadeMax){fadeValue=fadeMax;dir=-1} if(fadeValue<=fadeMin){fadeValue=fadeMin;dir=1}
          layerAfter.style.opacity=(fadeValue/100).toFixed(2); fadeRange.value=fadeValue.toFixed(0); fadePct.textContent=fadeRange.value+'%';
        }else if(currentMode==='slider'){
          splitValue+=dir*splitSpeed*16; if(splitValue>=splitMax){splitValue=splitMax;dir=-1} if(splitValue<=splitMin){splitValue=splitMin;dir=1}
          layerAfter.style.opacity=1; applySplit(splitValue);
        }
        introRAF=requestAnimationFrame(frame);
      }
      introRAF=requestAnimationFrame(frame);
    }
    function stopIntroAnimation(){
      introRunning=false; if(introRAF) cancelAnimationFrame(introRAF);
      if(currentMode==='slider'){
        const from=parseFloat((sliderHandle.style.left||'').replace('%','')); const f=isNaN(from)?50:from; const to=50, dur=400, t0=performance.now();
        const ease=t=>1-Math.pow(1-t,3);
        function step(ts){const p=Math.min(1,(ts-t0)/dur); applySplit(f+(to-f)*ease(p)); if(p<1) requestAnimationFrame(step)}
        requestAnimationFrame(step); layerAfter.style.opacity=1;
      }
      introOverlay.style.display='none'; playPause?.focus?.();
    }

    function startBufferWatch(){
      if(bufferWatchTimer)return;
      el('intro-start-btn').disabled=false;
      bufferWatchTimer=setInterval(()=>{
        const tNow=playerBefore?.getCurrentTime?.()||0; updateBufferUI(tNow);
      },200);
    }

    // 再生開始
    el('intro-start-btn').addEventListener('click',()=>{ if(!started) beginPlaybackFromZero(); });
    function beginPlaybackFromZero(){
      started=true; autoplayBlocked=false;
      playerBefore.seekTo(0,true); playerAfter.seekTo(0,true);
      playBoth();
      stopIntroAnimation(); startBufferWatch(); startTicking();
    }

    // YouTube API
    window.onYouTubeIframeAPIReady=function(){
      const commonVars = {
        autoplay: 1, controls: 0, rel: 0, modestbranding: 1,
        playsinline: 1, fs: 0, iv_load_policy: 3, loop: 1, disablekb: 1, cc_load_policy: 0,
        origin: location.origin
      };
      playerBefore=new YT.Player('yt-before',{
        videoId:VIDEO_BEFORE.id,
        playerVars:{...commonVars, playlist: VIDEO_BEFORE.id},
        events:{onReady:(e)=>onReady('before',e), onStateChange:onStateChange}
      });
      playerAfter=new YT.Player('yt-after',{
        videoId:VIDEO_AFTER.id,
        playerVars:{...commonVars, playlist: VIDEO_AFTER.id},
        events:{onReady:(e)=>onReady('after',e), onStateChange:onStateChange}
      });
    };

    function onReady(which,e){
      try{e.target.mute()}catch{} try{e.target.setPlaybackQuality('hd1080')}catch{}
      if(which==='before')isReadyA=true;else isReadyB=true;

      if(isReadyA&&isReadyB){
        const dA=playerBefore.getDuration(), dB=playerAfter.getDuration(); totalDuration=Math.min(dA||0,dB||0); updateSeekUI(0);
        setMode('slider'); startIntroAnimation();

        // 自動再生可否（イントロ中のみ判定。イントロより優先してシールドは出さない）★
        setTimeout(checkAutoplay, AUTOPLAY_WATCH_MS_1);
        setTimeout(checkAutoplay, AUTOPLAY_WATCH_MS_2);

        startBufferWatch();
      }
    }

    function checkAutoplay(){
      if(!introRunning) return; // イントロ中だけ案内
      const stA=playerBefore.getPlayerState?.(), stB=playerAfter.getPlayerState?.();
      if(stA!==YT.PlayerState.PLAYING && stB!==YT.PlayerState.PLAYING){
        autoplayBlocked=true;
        introSub.textContent='ブラウザが自動再生を制限 — 「再生開始」を押してください';
        el('intro-start-btn').disabled=false;
      }else{
        // 再生できたらイントロを外して本再生
        beginPlaybackFromZero();
      }
    }

    function onStateChange(ev){
      if(!playerBefore||!playerAfter)return;
      const st=ev.data;

      if (st===YT.PlayerState.PAUSED) { // どちらかが停止→両方停止＋薄シールド
        try{playerBefore.pauseVideo()}catch{} try{playerAfter.pauseVideo()}catch{}
        isPlaying=false; playPause.textContent='▶ 再生'; playPause.setAttribute('aria-pressed','false'); showPauseShield(true);
      }
      if (st===YT.PlayerState.PLAYING) {
        if (!introRunning && !isPlaying) { playBoth(); }
        showPauseShield(false);
      }
      if (st===YT.PlayerState.ENDED) { // エンド画面に入らせない
        seekToBoth(0,true); playBoth();
      }
    }

    // 離脱
    window.addEventListener('beforeunload',()=>{ if(rafId) cancelAnimationFrame(rafId); if(intervalId) clearTimeout(intervalId); if(bufferWatchTimer) clearInterval(bufferWatchTimer); });
  </script>
</body>
</html>
